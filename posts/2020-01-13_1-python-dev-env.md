# 파이썬 개발환경 설정하기

네이버 테크 셰어에서 파이썬 개발 환경에 관해 공유한 내용 중 일부를 3부로 나누어 정리하였습니다.

이 글은 첫 편으로 pyenv로 여러 파이썬 버전과 파이썬 가상환경을 다루는 법을 다루었습니다.

## Python2 vs Python3
파이썬2의 지원이 끝난 시점에 이르렀으니 이 논쟁은 끝날 때도 되었다.
물론 여전히 남은 파이썬2 코드는 파이썬2로 계속 운영해야할지도 모른다.

하지만 다음과 같은 비교적 사소한 이유로 새 프로젝트를 파이썬2로 시작하기를 고려하고 있다면, 파이썬3를 쓰자.
(모두 지난 몇 년간 실제로 겪거나 들은 이유들이다)

- 꼭 써야 하는 라이브러리가 파이썬2 이후 더 이상 개발되지 않는 라이브러리여서
- 프로토타이핑에 쓴 코드를 파이썬2로 짰는데 서비스로 빨리 만들라고 해서
- 이전에 짠 파이썬2 프로젝트에서 무언가 복사해서 쓰기 편해서
- 파이썬2를 쓰는 기존 프로젝트를 반드시 지원해야 하는데 파이썬2/3 호환되는 코드를 짜기 어려워서

한국어로 이 글을 읽는 여러분이 파이썬 개발을 한다면, 대부분은 한국인 고객 타겟의 한국어 서비스일 것이고, 서비스가 아니더라도 대부분의 경우는 어떤 형태로든 한국어 데이터를 다루어야만 할 것이다. 다음 이유로 **파이썬2에서 영어 외의 텍스트를 다루는 것은 대부분의 경우 고통과 디버그 시간 낭비를 동반한다**. (만일 텍스트를 다루지 않는 예외적인 프로젝트에 착수하고자 하는 참이라면 이 부분은 무시하셔도 된다)

- 많은 파이썬2 코드는 여전히 문자열 데이터를 `unicode`가 아닌 `str`타입으로 두고 다룬다.
- 혹시나 문자열을 `unicode`로 다루는 코드를 사용하게 되더라도, `str`과 `unicode`는 애매모호하게 호환성이 높기 때문에, 타입이 `unicode`인지 아닌지 매순간 확인하지 않으면 누군가는 코드를 터뜨린다. 결국은 “한글이 깨지는“ 문제 디버그에만 많은 시간을 쓰게 될 가능성이 높아진다.
  - 문자열과 인코드 된 데이터를 엄밀히 구분할 수 있는 사람들로만 구성된 소수의 팀이라면 괜찮을수도 있지만요 :)
- 파이썬3 코드에서는 다행히도 `str` 타입이면 항상 신뢰하고 쓸 수 있다. `bytes`와 `str`은 거의 호환되지 않으므로 잘못 인코드된/인코드되지 않은 데이터가 들어오면 항상 깨지게 되어 쉽게 오류를 찾을 수 있다.
- 안타깝게도 Python2의 `str`/`unicode` 는 너무나도 쉽게 혼용되어서, 한 번 이런 코드를 만들게 되면 나중에 이 코드를 Python3로 옮기는 것은 상당한 시간이 걸린다. 반면 처음부터 Python3로 작성하게 된다면 혹시나 Python2를 지원해야 하는 불상사가 생기더라도 상대적으로는 쉬운 일이 된다.

다른 사소한 이유는 모두 덤이다. 처음부터 `str`/`unicode` 혼용으로 디버그하기 위해 낭비하는 시간만 아껴도 Python2 대신 Python3를 쓰는 댓가로 쓰는 시간보다는 더 아끼고도 남을 가능성이 높다.

크게 중요하지 않지만 다른 사소한 이유도 들어보자.
- 아직 파이썬3가 지원되지 않는 라이브러리는 앞으로도 유지보수되지 않을 가능성이 높을 것이다. 혹시 지금이라도 이슈에 파이썬3 지원 플랜이 있으면 일정에 맞춰서 이동을, 그렇지 않다면 대체제가 있으면 대체제를 쓰는 게 나을지도 모르겠다. 정말로 꼭 그 라이브러리를 써야하면 어쩌나? 안되는걸 어떡합니까, 별 수 없으니 파이썬2를 쓰셔야 겠지요...
- asyncio가 항상 성능 향상의 큰 이점을 가져다주는 것은 아니지만, 마이크로 서비스를 구성할때 별 다른 튜닝 없이도 유휴시간을 손쉽게 처리할 수 있는 것은 분명하다. 새롭게 시작하는 서비스가 마이크로서비스의 일부가 될 가능성이 있다면 asyncio를 쓰고 성능 튜닝에 들어가는 인건비를 절약하는 것을 고려해 보아야할 것이다.

## 여러 버전이 필요할 때, 여러 환경이 필요할 때

파이썬 커뮤니티에서는 종종 pyenv, virtualenv, conda, poetry 등이 역할 구분 없이 혼란스럽게 이야기되는 것을 종종 본다. 같은 층위의 것들을 비교하는 대신 다른 층위의 것들을 비교하면서 무엇이 다른 한 쪽 보다 낫다거나 하는 식이다.

- pyenv, conda는 여러 파이썬 버전을 다루기 위한 도구이다.
- venv, virtualenv는 한 파이썬 버전에서 여러 격리된 환경을 만들기 위한 도구이다. 하지만 pyenv나 conda를 쓰면 이 역할이 별도로 래핑되어 있다. 아마 이것이 혼란의 원인일 것이다.
- poetry는 만들어진 환경 안에서 의존성을 잘 다루기 위한 도구이다.

하지만 도구들이 각자의 영역에서 시작해서 경계를 넘어서 확장되나는 부분이 있기도 하다.

## 특정 파이썬 버전이 필요할 때, 여러 파이썬 버전이 필요할 때

시스템에 설치된 '아무' 파이썬 버전을 쓸 수 없을 때가 많다. 파이썬이 설치되어 있지 않은 윈도우에서는 오히려 원하는 파이썬 버전이 1개이면 문제가 덜한 편이지만, 리눅스나 맥에서는 시스템에 설치된 버전이 내가 원하는 버전과 다르면 시스템 파이썬을 지우거나 덮어쓸 수 없는 경우가 많다. (할 수 있어 보이더라도 하지 말자, 보통은 시스템 구성요소가 의존하는 버전이다)

대부분의 진지한 개발 환경은 모든 구성원이 통일된 파이썬 버전을 사용해 개발하고 같은 버전의 파이썬으로 배포하는 것이 권장되기 때문에, 특정 버전을 맞추는 것이 필수적이다. 모든 팀원의 개발장비와 배포할 타겟의 파이썬 버전이 저절로 맞지는 않으므로 (최소한 한 명을 제외한 나머지) 모두가 버전을 맞추기 위한 노력을 들여야만 한다. 따라서 설사 하나의 파이썬 버전만이 필요한 상황이라 하더라도, 로컬에서 적당히 돌려서 결과만 내면 되는 코드가 아니라 협업이나 배포를 고려해야 한다면 이 방법에 따라 버전을 고정하는 것을 권장한다.

### 정말로 파이썬 버전을 일치시킬 필요가 있을까?

1년도 안된 따끈따끈하고도 끔찍한 사례를 소개한다.

2019년 4월 파이썬 3.7.3에서 (아마도 최소한 과반의 파이썬 프로젝트는 어떤 형태로든 사용하고 있으리라 짐작되는) [`functools.lru_cache`가 망가졌다](https://bugs.python.org/issue36650). 불행히도 대부분 간단한 함수를 캐시하는데는 큰 이상이 없었으므로 배포까지 문제가 드러나지 않았고, 그 와중에 인터넷에 널리 공유되던 메서드를 캐시하는 스니펫이 마침 이 버그를 밟고 있었다. 빵!

개발 장비로 파이썬 3.7.4를 쓰고 있었고, 배포 타겟은 3.7.3을 쓰고 있었다고 생각해보자. 운이 없게도 하필 버그를 밟는 코드도 쓰고 있었다면 이 서비스는 과연 어떻게 되었을까? 누가 보더라도 3.7.4와 3.7.3은 사실상 거의 같은 버전이다. 방심하고 배포하기에도, 배포 후에 왜 갑자기 lru_cache에서 문제가 생기는지 영문을 모르고 어리둥절하기에도 충분한 정도의 비슷한 버전인 것이다. 그저 버전을 맞춰서 배포하는 것만으로도 이런 사고는 쉽게 방지할 수 있다.

**사심이 담긴 광고**: 메서드를 캐시할 때는 [methodtools](https://pypi.org/project/methodtools/)를 추천한다.

### 권장하지 않는 방법

- 흔한 오해: `venv` 또는 `virtualenv` 라는 이름이 주는 이미지 때문에 이것으로 여러 파이썬 버전 문제를 해결할 수 있다고 생각하는 경우가 많다. 이 것은 같은 파이썬 버전을 사용하는 여러 프로젝트를 격리하는 데 쓰는 도구이다.

다음과 같은 방법이 쓰인다는 이야기를 여기저기서 듣고 있다. 오랜 옛날이나 특정 환경에서는 맞는 방법일수도 있겠으나 피할 수 있으면 이러지 말자.
- 고생길1: 필요한 파이썬 버전을 모두 설치해서 절대경로나 alias로 접근해서 쓰자
- 고생길2: 내가 필요한 버전을 배포판이 제공하지 않으니 소스를 다운받아 빌드해서 쓰자
- 고생길3: docker가 모든걸 하는 세상이니 docker로 파이썬 개발 환경을 만들어 쓰자

### pyenv

일반적으로 편리한 방법은
1. pyenv를 이용해 `pyenv install` 로 여러 파이썬을 설치하고
1. `pyenv virtualenv` 로 가상 환경을 만들고
1. `pyenv local` 로 디렉토리마다 사용할 버전을 지정하는 것이다.

파이썬 버전을 골라서 한 번만 잘 설치하면 귀찮게 pyenv를 설치하고 pyenv로 파이썬을 설치하는 것보다 낫다고 생각될지도 모른다. 하지만 보안 문제나 버그픽스가 포함된 마이너 버전 업그레이드는 종종 하게 될 것이라는 점을 잊지 말자.

대안: 윈도우에서 개발해야 해서 pyenv가 잘 되지 않거나, 데이터를 다루는 팀이라던가 하는 이유로 주위에서 모두 anaconda나 miniconda를 쓴다면 이 것도 충분히 좋다고 한다.

pyenv를 쓴다면 첫 줄에 언급한대로 대체로 다음 명령을 쓸 줄 알면 족하다.
- `pyenv install`
- `pyenv virtualenv`
- `pyenv local` (종종 `pyenv global`, `pyenv shell`)
- 처음 설정할 때 `pyenv init`가 필요하지만 잘 몰라도 시키는대로 하면 그만이다.

대표적인 시나리오 몇 개를 공유한다. 만일 시나리오에 포함되지 않아 어떻게 해야할지 모르겠다면, 문의를 보내주시면 같은 시나리오를 알려드리거나 사례에 보충하겠다.

#### 시나리오1: 시스템과 다른 버전 설치해 쓰기

시스템에 설치된 파이썬은 2.7이고 시스템에서 python3 패키지를 설치하면 3.5가 설치된다. 하지만 나는 3.7에서 추가된 기능을 쓰고 싶다.

```shell
$ pyenv install --list  # 설치 가능한 버전 확인
$ pyenv install 3.7.4
$ pyenv virtualenv 3.7.4 <venv_name>  # pyenv-virtualenv는 아래에서 다시 설명할 것이다.
$ pyenv local <venv_name>
```

`<venv_name>`은 새로 만들어 쓸 가상환경의 이름이다.

#### 시나리오2: 여러 버전을 지원해야 하는 라이브러리 테스트하기

내가 만드는 라이브러리는 파이썬 2.7, 3.6, 3.8에서 동작이 보장되어야 한다.

```shell
$ pyenv install 2.7.15 3.6.3 3.8.1
$ pyenv local 2.7.15 3.6.3 3.8.1  # 한 번에 3개 버전을 모두 활성화 한다
$ tox  # 물론 tox 설정에 2.7, 3.4, 3.7을 지정해야 할 것이다.
```

이런식으로 여러 버전을 활성화 시키면, `python2.7`, `python3.6`, `python3.8` 명령이 활성화되고 tox가 이 명령을 사용하는 식이다. 기본 `python`은 이 가운데 하나로 고정된다.

#### 시나리오3: CI, cron, 배포환경 등에서 특정 버전의 파이썬으로 실행하기

```shell
$ pyenv install 3.6.3
$ pyenv shell 3.6.3 && pytest
```
또는
```shell
$ pyenv install 3.6.3
$ ~/.pyenv/versions/3.6.3/bin/pytest
```

물론 3.6.3과 같이 특정 버전을 지정하는 대신, 첫 시나리오와 같이 `pyenv-virtualenv`로 만든 가상환경으로 대체할 수 있다.

travis-ci 같은 CI 서비스에서도 여러 파이썬 버전 설치를 위해 `pyenv`를 사용하고 있다.

#### 시나리오4: 낡은 centos 서버가 파이썬 2.6을 기본으로 쓰고 있는데, 좀 편하게 3.7이 기본 버전인 것처럼 쓰고 싶다.

```shell
$ pyenv install 3.7.4
$ pyenv global 3.7.4
```

#### 요약

pyenv로
- 디렉터리별 (pyenv local)
- 열려 있는 셸 별 (pyenv shell, venv의 activate 스크립트와 같음)
- 시스템 전체 (pyenv global)
에 사용할 파이썬 버전을 지정할 수도 있고, 한 번에 여러 버전을 활성화할 수도 있다.

conda도 비슷한 기능을 제공한다.

### docker에 관한 변명
기본적으로 docker 사용을 추천하지 않는 이유는 docker를 쓰는 것만으로 (pyenv와는 비교할 수 없는 수준으로) 어느 정도의 복잡도와 번거로움이 발생하기 때문이다. 하지만 docker가 pyenv보다 더 나은 수준의 가상화를 지원한다는 점은 논쟁의 여지가 없다. docker 구루여서 사용에 아무런 불편함을 느끼지 않거나, 파이썬 외에 함께 격리해야할 다른 환경이 많다면 docker 사용이 pyenv보다 더 나을 수 있다.

이를테면 프로젝트별로 파이썬의 버전과 postgresql의 버전을 동시에 고정하려면 어떻게 해야 하냐는 지적이 있었다. pg가 pyenv같은 도구를 제공하지 않기 때문에 문제가 더 어려워지지만, 혹여나 그런 도구가 있다 하더라도 여전히 docker가 pyenv보다 일관성 있는 설정 방법이 될 것이다.

## 프로젝트 간에 가상환경 분리하기

여러 프로젝트를 개발하다보면, 또는 파이썬 유틸리티도 설치해 쓰면서 개발도 함께 하다 보면 가상환경 없이는 의존성이 잘 관리되지 않는다.
특히나 `pip freeze`를 이용해 현재 사용중인 의존성의 버전을 고정하고 있다면 분리되지 않은 환경에서는 불필요한 패키지가 나와 번거롭기까지 하다.

### 전통: venv

전통적으로 파이썬 사용자들은 다음과 같이 venv를 쓴다.

```shell
$ python -m venv <venv_dir>  # 사용한 python버전과 같은 버전의 가상환경을 `<venv_dir>` 디렉토리에 만든다
$ ./<venv_dir>/bin/activate  # 현재 사용중인 셸에서 활성화 한다.
```
Note: 이제 파이썬에 `venv`가 내장되어 있으므로, 더 이상 `virtualenv`는 사용할 필요가 없다. 둘의 동작은 완전히 같지는 않지만, 실용적으로 같다고 보아도 된다.

`venv`나 `virtualenv`는 당장 추천하는 영역이 아니므로 자세한 설명은 생략한다.

### pyenv-virtualenv

하지만 앞의 pyenv 파트에서 언급했듯이 대체로 진지한 개발에는 특정 버전을 고정하는 것이 필요하므로, pyenv를 쓰도록 이미 설득되었을(?) 것이다. pyenv를 쓸 때도 pyenv와 연결된 파이썬과 직접 설치한 파이썬 사이에는 아무 차이도 없으므로, 위와 같은 방법으로 가상 환경을 만들 수도 있다.
 
하지만 `pyenv`에는 `pyenv-virtualenv`라는 별도의 기능이 있어서 마치 가상 환경을 pyenv에 설치한 파이썬 버전 가운데 하나인 것처럼 다루게 해준다.

Note: 보통 `pyenv-virtualenv`는 `pyenv`와는 따로 설치해야 하는 확장이다.

```shell
$ pyenv virtualenv 3.6.3 <venv_name>  # pyenv로 설치한 3.6.3의 가상환경을 만든다.
$ pyenv shell <venv_name>  # 위에서 activate를 직접 실행하는 것과 같다
$ ~/.pyenv/versions/<venv_name>/bin/activate  # 필요하다면 이전과 같이 직접 activate 해줄 수도 있다.
```

`<venv_name>`은 가상환경의 이름이다. `venv`와 달리 로컬에 생성하지 않고 `pyenv`의 `versions` 디렉터리 안에 생성된다.

### pyenv local

이렇게 사용하는 것의 장점 가운데 하나는 `pyenv local` 을 이용해 특정 디렉토리에서 사용할 파이썬 버전을 자동으로 고정할 수 있다는 것이다. `pyenv local` 명령을 사용하면 매번 activate 스크립트를 실행하는 번거로움이 줄어든다.

```shell
$ pyenv local <venv_dir>  # 이제 이 디렉토리에 들어올때마다 자동으로 이 가상환경이 활성화 된다
```

### 팁: direnv

혹시나 `pyenv`를 사용하지 못하고 `venv`를 사용해야 하는 상황이라면 [direnv](https://direnv.net/)를 사용하자. 디렉터리에 들어갈 때마다 임의의 셸 스크립트를 실행하므로 activate를 넣어두면 `pyenv local`과 비슷한 효과를 볼 수 있다.

물론 파이썬 가상환경 activate 외에 다른 자동으로 실행할 일이 있을 때도 유용한 도구이다.
